@page "/race/{RaceId:long}"
@inject IncidentService _incidentService
@inject RaceService _raceService
@inject SeasonService _seasonService
@inject TyreService _tyreService
@inject NavigationManager _nav
@inject IDialogService _dialogService
@inject ISnackbar _snackbar
@inject IOptions<SimConfig> _config

<PageTitle>Race</PageTitle>

<MudContainer MaxWidth="MaxWidth.False" Class="mt-4" id="race-display">
    @if (!loading)
    {
        <MudPaper MinHeight="60px" Width="100%">
            <MudStack Row="true" AlignItems="AlignItems.Center">
                <CountryFlag Code="@Model.Country" />
                <MudText Typo="Typo.h5">@Model.Name - ROUND @Model.Round</MudText>

                <MudSpacer />

                <MudIcon Icon="@Model.ClimateIcon" />
                <MudText>@Model.Climate</MudText>

                <MudSpacer />

                <MudSwitchM3 @bind-Checked="tooMuchInfo"
                             Label="TMI"
                             Color="Color.Secondary"
                             ThumbIcon="@Icons.Material.Filled.Done"
                             ThumbOffIcon="@Icons.Material.Filled.Close" />
            </MudStack>
        </MudPaper>
        <MudTable Items="@Model.RaceDrivers.OrderBy(e => (int)e.Status).ThenBy(e => e.Position)" Dense="true" Class="extra-dense overflow-x-hide">
            <ToolBarContent>
                <MudStack Row="true" AlignItems="AlignItems.Center" Class="mud-width-full">
                    <MudStack Spacing="0" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.subtitle2">Advance laps:</MudText>
                        <MudChipSet SelectedChipChanged="ChangeCalculationPerAdvance" Mandatory="true">
                            <MudChip Value="1">@(NumberHelper.CalcLapCount(1 * calculationDistance, Model.TrackLength))</MudChip>
                            <MudChip Value="5" Default="true">@(NumberHelper.CalcLapCount(5 * calculationDistance, Model.TrackLength))</MudChip>
                            <MudChip Value="10">@(NumberHelper.CalcLapCount(10 * calculationDistance, Model.TrackLength))</MudChip>
                        </MudChipSet>
                    </MudStack>
                    
                    <MudSpacer />

                    <MudChip Color="@lapIndicatorColor" Label="true" DisableRipple="true">
                        <MudText Typo="Typo.h4">@(racedLaps) / @(totalLaps)</MudText>
                    </MudChip>

                    <MudSpacer />

                    <MudButtonGroup Color="Color.Tertiary">
                        @if (!Model.IsFinished)
                        {
                            @if (calculated >= calculationCount)
                            {
                                <MudButton OnClick="Finish">Finish</MudButton>
                            }
                            else
                            {

                                <MudButton OnClick="Advance">Advance</MudButton>
                            }
                        }
                        <ScreenshotButton TargetId="race-display" />
                    </MudButtonGroup>
                </MudStack>
            </ToolBarContent>
            <HeaderContent>
                <MudTh Style="width: 15px">#</MudTh>
                <MudTh Style="width: 40px">Grid</MudTh>
                <MudTh Class="pa-0" Style="width: 5px"></MudTh>
                <MudTh Style="width: 220px">Name</MudTh>
                <MudTh Class="number-col" Style="width: 30px">No</MudTh>
                <MudTh Style="width: 220px">Team</MudTh>
                <MudTh Class="number-col" Style="width: 30px">PWR</MudTh>
                <MudTh Style="width: 175px">ATT/DEF</MudTh>
                <MudTh Class="tyre-col" Style="width: 50px">TYRE</MudTh>
                <MudTh Class="number-col" Style="width: 30px">Pace</MudTh>
                <MudTh Class="number-col-lg" Style="width: 50px">Status</MudTh>
                @if (tooMuchInfo)
                {
                    <MudTh Class="number-col" Style="width: 30px">Score</MudTh>
                }
                <MudTh Style="width: 500px">Progression</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>
                    <DriverPosition Number="@context.Position" Colour="@context.Colour" Accent="@context.Accent" />
                </MudTd>
                <MudTd>
                    <GridChange Change="@context.GridChange" />
                </MudTd>
                <MudTd Class="pa-0">
                    <span class="smol-accent" style="@(ViewHelper.SetBackgroundColour(context.Colour))"></span>
                </MudTd>
                <MudTd Class="overflow-hider">
                    <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.body1">@context.FirstName</MudText>
                        <MudText Typo="Typo.button">@context.LastName</MudText>
                        @if (context.HasFastestLap)
                        {
                            <MudIcon Icon="@Icons.Material.Filled.Timer" Size="Size.Small" Style="color:mediumpurple" />
                        }
                        <MudSpacer />
                        <CountryFlag Code="@context.Nationality" Size="FlagSize.Small" />
                    </MudStack>
                </MudTd>
                <MudTd Class="number-col" Style="@(ViewHelper.SetFullColourstyle(context.Colour, context.Accent))">
                    <MudText Typo="Typo.caption">@context.Number</MudText>
                </MudTd>
                <MudTd Class="overflow-hider">
                    <MudText Typo="Typo.button">@context.TeamName</MudText>
                </MudTd>
                <MudTd Class="number-col">
                    <MudText Typo="Typo.caption">@context.Power</MudText>
                </MudTd>
                <MudTd>
                    <MudStack Row="true" Spacing="1" Justify="Justify.SpaceEvenly" AlignItems="AlignItems.Center" Class="pa-0 mud-width-full">
                        <MudIcon Icon="@IconCollection.Sword" Size="Size.Small" />
                        <MudText Typo="Typo.caption">@context.Attack</MudText>
                        <sup>@(context.OvertakeCount)</sup>
                        <span class="py-2" style="background-color: antiquewhite;padding-left: 1px;padding-right: 1px;"></span>
                        <MudText Typo="Typo.caption">@context.Defense</MudText>
                        <sup>@(context.DefensiveCount)</sup>
                        <MudIcon Icon="@IconCollection.ShieldChevron" Size="Size.Small" />
                    </MudStack>
                </MudTd>
                <MudTd Class="tyre-col">
                    <TyreElement Colour="@context.CurrentTyre.Colour">@context.TyreLife</TyreElement>
                </MudTd>
                <MudTd Class="number-col">
                    <GradientColour Min="@lastLowestScore" Max="@lastHighestScore" Value="@context.LastScore">
                        <MudText Typo="Typo.caption" Color="Color.Inherit">@context.LastScore</MudText>
                    </GradientColour>
                </MudTd>
                <MudTd Class="number-col-lg">
                    @if (context.Incident == null)
                    {
                        <MudText Typo="Typo.caption">+@(Math.Round((highestScore - context.LapSum) * gapMarge, 2))</MudText>
                    }
                    else
                    {
                        <MudText Typo="Typo.button" Color="Color.Error">@context.Incident.Name</MudText>
                    }
                </MudTd>
                @if (tooMuchInfo)
                {
                    <MudTd Class="number-col">
                        <MudText Typo="Typo.caption">@context.LapSum</MudText>
                    </MudTd>
                }
                <MudTd>
                    <div class="relative" style="height:8px;width:100%">
                        @foreach (var lapEvent in context.LapScores)
                        {
                            @foreach (var raceEvent in lapEvent.ListOfDubiousEvents().Select((element, index) => new { index, element }))
                            {
                                <SignalIcon LapPercentage="@(NumberHelper.Percentage(lapEvent.Order, calculationCount))"
                                            Signal="@raceEvent.element.ToString()"
                                            Index="@raceEvent.index" />
                            }
                        }
                    </div>

                    @if (altProgress)
                    {
                        <SimProgressLinear Bars="@(context.LapScores.Select(e => ((NumberHelper.Percentage(1, calculationCount)), e.DetermineLapColour())).ToList())" />
                    }
                    else
                    {
                        <MudProgressLinear Value="@(NumberHelper.CalcLapCount(context.LastLapOrder * calculationDistance, Model.TrackLength))"
                                           Min="0"
                                           Max="@totalLaps"
                                           Size="Size.Medium"
                                           Color="@Color.Primary"
                                           Class="my-2" />
                    }
                </MudTd>
            </RowTemplate>
            <FooterContent>
                <MudTd colspan="20">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Class="pa-0">
                        <MudText Typo="Typo.button">Legend</MudText>
                        <MudChip Icon="@IconCollection.HelmetOff" IconColor="Color.Error" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            DNF Driver
                        </MudChip>
                        <MudChip Icon="@IconCollection.CarCrash" IconColor="Color.Error" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            DNF Car
                        </MudChip>
                        <MudChip Icon="@IconCollection.EngineOff" IconColor="Color.Error" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            DNF Engine
                        </MudChip>
                        <MudChip Icon="@Icons.Material.Filled.ErrorOutline" IconColor="Color.Warning" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            Mistake
                        </MudChip>
                        <MudChip Icon="@Icons.Material.Filled.LocalGasStation" IconColor="Color.Success" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            Pitstop
                        </MudChip>
                        <MudChip Icon="@Icons.Material.Filled.SwapVert" IconColor="Color.Info" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            Driver Swap
                        </MudChip>
                        <MudChip Icon="@IconCollection.Skull" IconColor="Color.Inherit" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true" Style="color: white">
                            Fatality
                        </MudChip>
                        <MudChip Icon="@IconCollection.AlertTriangle" IconColor="Color.Warning" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            Caution (TEMP)
                        </MudChip>
                        <MudChip Icon="@Icons.Material.Filled.QuestionMark" IconColor="Color.Warning" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                            Undetermined
                        </MudChip>

                        <MudSpacer />

                        <MudMenu Label="Charts" Icon="@Icons.Material.Filled.InsertChart" Color="Color.Tertiary">
                            <MudMenuItem OnClick="ToggleProgressBarType">Progress toggle</MudMenuItem>
                            <MudMenuItem OnClick="ShowGapperChart">Gapper chart</MudMenuItem>
                            <MudMenuItem OnClick="ShowPositionChart">Position chart</MudMenuItem>
                        </MudMenu>
                    </MudStack>
                </MudTd>
            </FooterContent>
        </MudTable>
    }
</MudContainer>

@code {
    [Parameter]
    public long RaceId { get; set; }

    public RaceModel Model { get; set; }

    List<Tyre> tyres;
    List<Incident> possibleIncidents;

    bool loading = true;
    bool altProgress = false;
    bool tooMuchInfo = false;

    int fatalityOdds;
    int disqualifyChance;
    int safetyCarOdds;
    int safetyReturnOdds;
    int mistakeRolls;
    int mistakeMin;
    int mistakeMax;
    int battleRng;
    double gapMarge;

    int fastestLap;
    int highestScore;
    int racedLaps;
    int totalLaps;
    int minLapRng;
    int maxLapRng;
    int pitMin;
    int pitMax;

    int calculated;
    int calculationCount;
    int calculationsPerAdvance = 5;
    int calculationDistance = 10;

    bool safetyCarOut = false;
    Color lapIndicatorColor = Color.Dark;
    Entrant cycleReliabilty = Entrant.Driver;

    int lastHighestScore = 0;
    int lastLowestScore = 0;

    protected override async Task OnInitializedAsync()
    {
        tyres = await _tyreService.GetTyres(StateFilter.Active);
        possibleIncidents = await _incidentService.GetIncidents(StateFilter.Active);

        Model = await _raceService.RetrieveRaceModel(RaceId);

        minLapRng = Model.Season.RngMinimum;
        maxLapRng = Model.Season.RngMaximum;
        pitMin = Model.Season.PitMinimum;
        pitMax = Model.Season.PitMaximum;

        fatalityOdds = _config.Value.FatalityChance;
        disqualifyChance = _config.Value.DisqualifyChance;
        safetyCarOdds = _config.Value.SafetyCarChance;
        safetyReturnOdds = _config.Value.SafetyCarReturnChance;
        mistakeRolls = _config.Value.MistakeAmountRolls;
        mistakeMin = _config.Value.MistakeLowerValue;
        mistakeMax = _config.Value.MistakeUpperValue;
        battleRng = _config.Value.BattleRng;
        gapMarge = _config.Value.GapMarge;

        calculationDistance = _config.Value.CalculationDistance;
        calculated = Model.RaceDrivers.Select(e => e.LapScores.Count()).Max();
        calculationCount = Model.RaceLength / calculationDistance;

        racedLaps = NumberHelper.CalcLapCount(calculated * calculationDistance, Model.TrackLength);
        totalLaps = NumberHelper.CalcLapCount(Model.RaceLength, Model.TrackLength);

        if (Model.IsFinished)
        {
            highestScore = Model.RaceDrivers.Max(e => e.LapSum);
            fastestLap = Model.RaceDrivers.SelectMany(e => e.LapScores).Max(e => e.Score);
        }

        loading = false;
    }

    void ChangeCalculationPerAdvance(MudChip? calcChip)
    {
        if (calcChip != null)
            calculationsPerAdvance = (int)calcChip.Value;
    }

    void ToggleProgressBarType() => altProgress = !altProgress;

    bool DidReliabilityFail(int reliability) => NumberHelper.RandomInt(1000) > reliability;

    void Advance()
    {
        // Use this variable to persist the lap scores which were generated in this advance
        var lapScoresToPersist = new List<LapScore>();

        // Every i in this instance is relative to 10km (or calculationDistance) of racing aka a calculation
        for (int i = 0; i < calculationsPerAdvance; i++)
        {
            // Prevent continuing the advancing if we have already reached the limit
            if (calculated >= calculationCount)
                break;

            ++calculated;
            long? newFastestLapScorer = null;

            // Logic for what happens during a SC goes here
            if (safetyCarOut)
            {
                var safetyCarGoesBackIn = HandleSafetyMoment(lapScoresToPersist);
                if (safetyCarGoesBackIn)
                {
                    // After handling a safety car round, it goes back in
                    lapIndicatorColor = Color.Dark;
                    safetyCarOut = false;
                }

                continue;
            }

            foreach (var driver in Model.RaceDrivers.Where(e => e.Status == RaceStatus.Racing))
            {
                driver.InstantOvertaken = false;

                var lapScore = new LapScore { ResultId = driver.ResultId, Order = calculated };

                // Determine if either driver, car or engine has failed
                var safetyCarOccurrence = CheckReliability(driver, lapScore);

                // Calculate the score for drivers which are still racing
                if (driver.Status == RaceStatus.Racing)
                {
                    var minRng = (minLapRng + driver.RngMinMod);
                    var maxRng = (maxLapRng + driver.RngMaxMod);

                    int lapValue = NumberHelper.RandomInt(minRng, maxRng);

                    // Adds the qualifying bonus in the first lap, should be thought about once more though in terms of what we do with this
                    if (calculated == 1)
                        lapValue += Model.QualifyingBonus(driver.Grid);

                    // Check if driver made a mistake, if so then it's going to cost him
                    for (int j = 0; j < mistakeRolls; j++)
                    {
                        if (DidReliabilityFail(driver.DriverReliability))
                        {
                            lapValue -= NumberHelper.RandomInt(mistakeMin, mistakeMax);
                            lapScore.RacerEvents |= RacerEvent.Mistake;
                            driver.InstantOvertaken = true;
                            break;
                        }
                    }

                    // Strategy
                    lapValue += HandleStrategy(driver, lapScore);

                    // Adds the overall power of the driver
                    lapValue += driver.Power;

                    if (lapValue > fastestLap)
                    {
                        fastestLap = lapValue;
                        newFastestLapScorer = driver.ResultId;
                    }

                    // Finally add the score to the lap results
                    lapScore.Score = lapValue;
                }
                else if (safetyCarOccurrence)
                {
                    // all sort of calculations to do here in relation to the current driver who caused a SC
                    safetyCarOut = safetyCarOccurrence;
                }

                driver.LapScores.Add(lapScore);
                lapScoresToPersist.Add(lapScore);
            }

            // Determine new positions (keep team role in mind here!)
            PostProcessAdvance(newFastestLapScorer);

            // TODO: handle something to deal with an active safety car which occurred in a previous advance
            if (safetyCarOut)
            {
                lapIndicatorColor = Color.Warning;
                // Stop iterating through all advances since SC occurrence
                break;
            }
        }

        racedLaps = NumberHelper.CalcLapCount(calculated * calculationDistance, Model.TrackLength);

        var lastScores = Model.RaceDrivers.Select(e => e.LastScore).ToArray();
        lastLowestScore = lastScores.Min();
        lastHighestScore = lastScores.Max();

        // Persist the new stint results, yes after doing all whats needed to show them
        //PersistLapScores(lapScoresToPersist);
    }

    bool CheckReliability(RaceDriver driver, LapScore lapScore)
    {
        var safetyCar = false;

        if (cycleReliabilty == Entrant.Driver && DidReliabilityFail(driver.DriverReliability))
        {
            lapScore.RacerEvents |= RacerEvent.DriverDnf;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Driver).ToList().TakeRandomIncident();
        }
        else if (cycleReliabilty == Entrant.Team && DidReliabilityFail(driver.CarReliability))
        {
            lapScore.RacerEvents |= RacerEvent.CarDnf;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Car).ToList().TakeRandomIncident();
        }
        else if (cycleReliabilty == Entrant.Engine && DidReliabilityFail(driver.EngineReliability))
        {
            lapScore.RacerEvents |= RacerEvent.EngineDnf;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Engine).ToList().TakeRandomIncident();
        }
        else { return safetyCar; }

        // Driver had a reliability failure, meaning he will immediatly be overtaken by any attacking driver
        driver.InstantOvertaken = true;

        // If enabled, then we're also going to check if anyone experienced a fatal crash
        if (Model.LeagueOptions.HasFlag(LeagueOptions.EnableFatality) && (NumberHelper.RandomInt(fatalityOdds) == 0))
        {
            safetyCar = true;

            driver.Status = RaceStatus.Fatal;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Lethal).ToList().TakeRandomIncident();
            lapScore.RacerEvents = RacerEvent.Death;

            return safetyCar;
        }

        // Randomly determines the odds a safety car occured due to the DNF'ing driver
        safetyCar = NumberHelper.RandomInt(safetyCarOdds) == 0;
        driver.Status = RaceStatus.Dnf;

        return safetyCar;
    }

    // Returns a number which will be added to the users lap score
    int HandleStrategy(RaceDriver driver, LapScore lapScore)
    {
        int valueScoreResult = driver.TyreLife;

        var tyreMinWear = driver.CurrentTyre.WearMin + driver.WearMinMod;
        var tyreMaxWear = driver.CurrentTyre.WearMax + driver.WearMaxMod;

        if (tyreMinWear > tyreMaxWear)
        {
            tyreMaxWear = tyreMinWear + 1;
            _snackbar.Add("A situation occurred where the maximum wear was lower than the minimum wear, please reconsider some set tyre wear values!");
        }

        // Maximum wear is more than the tyre can handle, it's time for a pitstop!
        if (tyreMaxWear > driver.TyreLife)
        {
            var distanceLeft = Model.RaceLength - (calculated * calculationDistance);
            var validTyres = tyres
                .Where(e => e.DistanceMin < distanceLeft && e.DistanceMax > distanceLeft && e.ForWet == Model.IsWet)
                .ToList();

            if (validTyres.Count > 0)
            {
                var nextTyre = validTyres.TakeRandomItem();

                driver.CurrentTyre = nextTyre;
                driver.TyreLife = nextTyre.Pace;
                driver.InstantOvertaken = true;

                lapScore.RacerEvents |= RacerEvent.Pitstop;

                valueScoreResult = driver.TyreLife;
                valueScoreResult -= NumberHelper.RandomInt(pitMin, pitMax);
            }
        }

        // Adds wear to the tyre
        driver.TyreLife -= NumberHelper.RandomInt(tyreMinWear, tyreMaxWear);

        return valueScoreResult;
    }

    // returns bool which indicates whether a safety car has been caused by a DNF-result
    bool HandleSafetyMoment(List<LapScore> lapScoresToPersist)
    {
        int scoreAboveDriver = 0;
        foreach (var driver in Model.RaceDrivers.Where(e => e.Status == RaceStatus.Racing).OrderBy(e => e.Position))
        {
            driver.InstantOvertaken = false;

            var lapScore = new LapScore { ResultId = driver.ResultId, Order = calculated };

            var scoreGap = scoreAboveDriver - driver.LapSum;

            if (scoreGap > 100)
            {
                var closingGap = scoreGap / 2;
                lapScore.Score += closingGap;
            }

            lapScore.RacerEvents |= RacerEvent.Caution;
            driver.LapScores.Add(lapScore);
            lapScoresToPersist.Add(lapScore);
        }

        return NumberHelper.RandomInt(safetyReturnOdds) == 0;
    }

    void PostProcessAdvance(long? newFastestLapHolder)
    {
        DeterminePositions();

        highestScore = Model.RaceDrivers.Max(e => e.LapSum);

        if (newFastestLapHolder != null)
        {
            foreach (var driver in Model.RaceDrivers)
            {
                driver.HasFastestLap = false;
                if (driver.ResultId == newFastestLapHolder)
                    driver.HasFastestLap = true;
            }
        }

        // Cycle reliability checking
        switch (cycleReliabilty)
        {
            case Entrant.Driver:
                cycleReliabilty = Entrant.Team;
                break;
            case Entrant.Team:
                cycleReliabilty = Entrant.Engine;
                break;
            case Entrant.Engine:
                cycleReliabilty = Entrant.Driver;
                break;
        }
    }

    void DeterminePositions()
    {
        int positionIndex = 0;
        foreach (var driver in Model.RaceDrivers.Where(e => e.Status == RaceStatus.Racing).OrderBy(e => e.Position))
        {
            var lastScore = driver.LapScores.Last();

            int gainedPositions = driver.Position - ++positionIndex;
            int positionChange = //positieverandering!!!!????!?!?!!???!!!

            while (gainedPositions > 0)
            {
                var abovePosition = driver.Position - 1;
                if (abovePosition == 0)
                    break;

                var aboveDriver = Model.RaceDrivers.First(e => e.Position == abovePosition);

                // Driver above is teammate AND support driver AND attacker is main driver, swap time!
                if (aboveDriver.SeasonTeamId == driver.SeasonTeamId && driver.Role == TeamRole.Main && aboveDriver.Role == TeamRole.Support)
                {
                    lastScore.RacerEvents |= RacerEvent.Swap;
                    aboveDriver.LapScores.Last().RacerEvents |= RacerEvent.Swap;
                }
                else if (!aboveDriver.InstantOvertaken)
                {
                    // Subtract attack value from defense, what's left is how much the attacker is hindered
                    var attackingResult = driver.Attack + NumberHelper.RandomInt(battleRng);
                    var defendingResult = aboveDriver.Defense + NumberHelper.RandomInt(battleRng);
                    var battleCost = defendingResult - attackingResult;

                    if (battleCost > 0)
                        lastScore.Score -= battleCost;

                    // Overtake failed
                    if (aboveDriver.LapSum > driver.LapSum)
                    {
                        aboveDriver.DefensiveCount++;
                        driver.LastScore = lastScore.Score;
                        break;
                    }

                    // It only counts as an overtake if it wasn't in an instant
                    driver.OvertakeCount++;
                }

                // Overtake succeeded, driver gains a position!
                (driver.Position, aboveDriver.Position) = (aboveDriver.Position, driver.Position);

                gainedPositions--;
            }

            driver.LastScore = lastScore.Score;
        }
    }

    void PreProcessFinish()
    {
        bool anyoneDisqualified = false;

        foreach (var driver in Model.RaceDrivers.Where(e => e.Status == RaceStatus.Racing))
        {
            if (NumberHelper.RandomInt(disqualifyChance) == 0)
            {
                driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Disqualified).ToList().TakeRandomIncident();
                driver.Status = RaceStatus.Dsq;

                anyoneDisqualified = true;
            }
        }

        if (anyoneDisqualified)
        {
            var racingDrivers = Model.RaceDrivers.OrderBy(e => (int)e.Status).ThenByDescending(e => e.LapSum).ToList();
            int positionIndex = 0;

            foreach (var driver in racingDrivers)
                driver.Position = ++positionIndex;
        }
    }

    async Task Finish()
    {
        PreProcessFinish();

        var allotments = Model.Season.PointAllotments?.ToDictionary(e => e.Position, e => e.Points) ?? new();
        var finishedResults = Model.RaceDrivers.Select(e => e.ToResult(RaceId)).ToList();
        var scoredPoints = Model.RaceDrivers
            .Select(e => e.ToScoredPoints(allotments, Model.Season.PointsPole, Model.Season.PointsFastestLap))
            .ToList();

        // Should be removed when it is done per advance
        var allLapScores = Model.RaceDrivers.SelectMany(e => e.LapScores).Where(e => e.Id == 0).ToList();

        await _raceService.PersistLapScores(allLapScores);
        await _raceService.FinishRace(RaceId, finishedResults, scoredPoints);

        if (Model.LeagueOptions.HasFlag(LeagueOptions.EnablePenalty))
        {
            await _seasonService.CheckPenalties(finishedResults);
        }

        _nav.NavigateTo($"/postrace/{RaceId}");
    }

    async Task ShowGapperChart()
    {
        var parameters = new DialogParameters { ["Drivers"] = Model.RaceDrivers };
        _ = await _dialogService.ShowAsync<GapChartDialog>("Gapper chart", parameters, Constants.DefaultChartDialogSettings);
    }
    async Task ShowPositionChart()
    {
        var parameters = new DialogParameters { ["Drivers"] = Model.RaceDrivers };
        _ = await _dialogService.ShowAsync<PositionChangeChart>("Position chart", parameters, Constants.DefaultChartDialogSettings);
    }
}
