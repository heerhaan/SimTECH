@inject IDialogService _dialog

@if (!loading)
{
    <MudPaper Elevation="25" MinHeight="60px" Width="100%">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="pa-2">
            <div style="width:30%">
                <MudMenu Label="Charts" Icon="@Icons.Material.Outlined.InsertChart" Color="Color.Secondary" Variant="Variant.Text">
                    <MudMenuItem OnClick="ShowGapperChart">Gapper chart</MudMenuItem>
                    <MudMenuItem OnClick="ShowPositionChart">Position chart</MudMenuItem>
                </MudMenu>
            </div>
                
            <MudStack Spacing="0" AlignItems="AlignItems.Center">
                <MudText Typo="Typo.subtitle2">Advance laps:</MudText>
                <MudChipSet SelectedChipChanged="ChangeCalculationPerAdvance" Mandatory="true">
                    <MudChip Value="1" Color="Color.Primary">
                        @(NumberHelper.CalcLapCount(1 * calculationDistance, RaweCeek.Race.Track.Length))
                    </MudChip>
                    <MudChip Value="5" Default="true" Color="Color.Primary">
                        @(NumberHelper.CalcLapCount(5 * calculationDistance, RaweCeek.Race.Track.Length))
                    </MudChip>
                    <MudChip Value="10" Color="Color.Primary">
                        @(NumberHelper.CalcLapCount(10 * calculationDistance, RaweCeek.Race.Track.Length))
                    </MudChip>
                    <MudChip Value="@calculationCount" Color="Color.Primary">@totalLaps</MudChip>
                </MudChipSet>
            </MudStack>

            <div class="d-flex flex-row-reverse" style="width:30%">
                <MudButtonGroup Variant="Variant.Outlined" Color="Color.Tertiary">
                    <ScreenshotButton TargetId="race-display" Class="btn-md" />
                    @if (RaweCeek.Race.State != State.Closed)
                    {
                        @if (calculated >= calculationCount)
                        {
                            <MudButton OnClick="Finish" Class="btn-md">Finish</MudButton>
                        }
                        else
                        {
                            <MudButton OnClick="Advance" Class="btn-md">Advance</MudButton>
                        }
                    }
                </MudButtonGroup>
            </div>
        </MudStack>
    </MudPaper>
    <div id="race-display">
        <MudTable Items="@raceDrivers.OrderBy(e => (int)e.Status).ThenBy(e => e.Position)"
                    Dense="true"
                    Class="extra-dense overflow-x-hide">
            <ToolBarContent>
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="pa-2 mud-width-full">
                    <div class="d-flex flex-row gap-3 align-center pa-0" style="width:30%">
                        <CountryFlag Code="@RaweCeek.Race.Track.Country" />
                        <MudText Typo="Typo.h5" Class="overflow-hider">@RaweCeek.Race.Name - ROUND @RaweCeek.Race.Round</MudText>
                    </div>

                    <MudChip Color="@lapIndicatorBackground" Label="true" DisableRipple="true">
                        <MudText Typo="Typo.h5" Color="@lapIndicatorColour">LAP @(racedLaps) / @(totalLaps)</MudText>
                    </MudChip>

                    <div class="d-flex flex-row-reverse align-center gap-3 pa-0" style="width: 30%">
                        <CustomIcon Icon="@RaweCeek.Climate.Icon" Colour="@RaweCeek.Climate.Colour">
                            <MudText Typo="Typo.h5" Color="Color.Inherit">@RaweCeek.Climate.Terminology</MudText>
                        </CustomIcon>
                    </div>
                </MudStack>
            </ToolBarContent>
            <HeaderContent>
                <MudTh Style="width: 15px"></MudTh>
                <MudTh Style="width: 40px">Grid</MudTh>
                <MudTh Class="pa-0" Style="width: 5px"></MudTh>
                <MudTh Style="max-width: 220px">Name</MudTh>
                <MudTh Class="number-col">NO</MudTh>
                <MudTh Style="max-width: 220px">Team</MudTh>
                <MudTh Class="number-col">PWR</MudTh>
                <MudTh Class="text-center" Style="width: 175px">ATT / DEF</MudTh>
                <MudTh Class="tyre-col">Tyre</MudTh>
                <MudTh Class="number-col">Pace</MudTh>
                <MudTh Class="number-col-lg">Status</MudTh>
                @if (tooMuchInfo)
                {
                    <MudTh Class="number-col">L.Gap</MudTh>
                    <MudTh Class="number-col">Score</MudTh>
                }
                <MudTh Style="min-width: 500px">Progression</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>
                    <DriverPosition Number="@context.Position" />
                </MudTd>
                <MudTd>
                    <GridChange Change="@context.GridChange" />
                </MudTd>
                <MudTd Class="accent-cell">
                    <SmolAccent Colour="@context.Colour" />
                </MudTd>
                <MudTd>
                    <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center" Class="pa-0" Style="max-width: 300px">
                        <MudText>@context.FirstName</MudText>
                        <MudText Typo="Typo.button" Class="fontsize-button-text overflow-hider">@context.LastName</MudText>
                        @if (context.HasFastestLap)
                        {
                            <MudIcon Icon="@Icons.Material.Filled.Timer" Size="Size.Small" Style="color:mediumpurple" />
                        }
                        <MudSpacer />
                        <CountryFlag Code="@context.Nationality" Size="ElementSize.Small" />
                    </MudStack>
                </MudTd>
                <MudTd Class="number-col">
                    <NumberDisplay Colour="@context.Colour" Accent="@context.Accent">@context.Number</NumberDisplay>
                </MudTd>
                <MudTd Class="overflow-hider" Style="max-width:250px">
                    <MudText Typo="Typo.button">@context.TeamName</MudText>
                </MudTd>
                <MudTd Class="number-col">
                    <MudText Typo="Typo.caption">@context.Power</MudText>
                </MudTd>
                <MudTd>
                    <MudStack Row="true" Spacing="1" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="pa-0 mud-width-full">
                        <MudIcon Icon="@IconCollection.Sword" Size="Size.Small" />
                        <MudText Typo="Typo.caption">@context.Attack</MudText>
                        <sup>@context.OvertakeCount</sup>
                        <span class="py-2" style="background-color: antiquewhite;padding-left: 1px;padding-right: 1px;"></span>
                        <MudText Typo="Typo.caption">@context.Defense</MudText>
                        <sup>@context.DefensiveCount</sup>
                        <MudIcon Icon="@IconCollection.ShieldChevron" Size="Size.Small" />
                    </MudStack>
                </MudTd>
                <MudTd Class="tyre-col">
                    <MudStack Row="true" Spacing="1" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="pa-0 mud-width-full">
                        <TyreElement Colour="@context.CurrentTyre.Colour">@context.CurrentTyre.Name.ElementAt(0)</TyreElement>
                        <sup>@context.TyreLife</sup>
                    </MudStack>
                </MudTd>
                <MudTd Class="number-col">
                    @if (context.Status == RaceStatus.Racing && context.SingleOccurrence == null)
                    {
                        <GradientColour Min="@lastLowestScore" Max="@lastHighestScore" Value="@context.LastScore">
                            <MudText Typo="Typo.caption" Color="Color.Inherit">@context.LastScore</MudText>
                        </GradientColour>
                    }
                    else
                    {
                        <MudText Typo="Typo.button" Color="Color.Warning">@(context.SingleOccurrence ?? "-")</MudText>
                    }
                </MudTd>
                <MudTd Class="number-col-lg">
                    @if (context.Incident == null)
                    {
                        <MudText Typo="Typo.caption">@context.GapAbove</MudText>
                    }
                    else
                    {
                        <MudText Typo="Typo.button" Color="Color.Error">@context.Incident.Name</MudText>
                    }
                </MudTd>
                @if (tooMuchInfo)
                {
                    <MudTd Class="number-col">
                        <MudText Typo="Typo.caption">+@((Math.Round((highestScore - context.LapSum) * gapMarge, 2)).ToString("F2"))</MudText>
                    </MudTd>
                    <MudTd Class="number-col">
                        <MudText Typo="Typo.caption">@context.LapSum</MudText>
                    </MudTd>
                }
                <MudTd>
                    <div class="relative" style="height:8px;width:100%">
                        @foreach (var lapEvent in context.LapScores)
                        {
                            @foreach (var raceEvent in lapEvent.ListOfDubiousEvents())
                            {
                                <SignalNote LapPercentage="@(NumberHelper.Percentage((lapEvent.Order - 1), calculationCount))"
                                            Signal="@raceEvent.ToString()" />
                            }
                        }
                    </div>
                    <SimProgressLinear Bars="@(context.ColoursOfUsedTyres(calculationCount))" />
                </MudTd>
            </RowTemplate>
        </MudTable>
        <MudPaper Class="pt-2 px-1">
            <SimProgressLinear Bars="@(occurrences.Select(e => ((NumberHelper.Percentage(1, calculationCount)), e.Value.SituationColour())).ToList())"
                                AddIndicator="true" LineSize="ElementSize.Normal" CalculationDistance="@calculationDistance" TrackLength="@RaweCeek.Race.Track.Length" />

            <MudStack Row="true" AlignItems="AlignItems.Center" Class="px-4 pt-5 pb-2">
                <MudText Typo="Typo.button">Legend</MudText>
                <MudChip Icon="@IconCollection.HelmetOff" IconColor="Color.Error" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                    Crash
                </MudChip>
                <MudChip Icon="@IconCollection.CarCrash" IconColor="Color.Error" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                    Issues
                </MudChip>
                <MudChip Icon="@IconCollection.EngineOff" IconColor="Color.Error" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                    Engine
                </MudChip>
                <MudChip Icon="@Icons.Material.Filled.ErrorOutline" IconColor="Color.Warning" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                    Mistake
                </MudChip>
                <MudChip Icon="@IconCollection.RefreshDot" IconColor="Color.Success" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                    Pitstop
                </MudChip>
                <MudChip Icon="@Icons.Material.Filled.SwapVert" IconColor="Color.Info" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                    Swap
                </MudChip>
                <MudChip Icon="@Icons.Material.Filled.Healing" IconColor="Color.Warning" Size="Size.Small" Variant="Variant.Text" DisableRipple="true" Label="true">
                    Injury
                </MudChip>
            </MudStack>
        </MudPaper>
    </div>
}

@code {
    [CascadingParameter] public RaweCeekModel RaweCeek { get; set; }

    [Parameter] public List<LapScore> LapScores { get; set; } = new();
    [Parameter] public List<RaceOccurrence> Occurrences { get; set; } = new();
    [Parameter] public IEnumerable<Incident> Incidents { get; set; } = Enumerable.Empty<Incident>();
    [Parameter] public IEnumerable<Tyre> Tyres { get; set; } = Enumerable.Empty<Tyre>();
    [Parameter] public SimConfig Config { get; set; } = new();
    [Parameter] public EventCallback OnFinish { get; set; } = new();

    private static readonly Entrant[] cycleableReliablities = new[] { Entrant.Driver, Entrant.Team, Entrant.Engine };

    Dictionary<int, SituationOccurrence> occurrences = new();
    List<RaceDriver> raceDrivers = new();
    List<Incident> possibleIncidents = new();
    List<Tyre> availableTyres = new();

    // Controls for the view
    bool loading = true;
    bool safetyCarOut = false;
    Color lapIndicatorBackground = Color.Dark;
    Color lapIndicatorColour = Color.Default;

    Entrant activeReliabilityCheck = Entrant.Driver;
    int reliablityCycler = 0;

    // Supportive caluclation fields
    int fatalityOdds;
    int disqualifyChance;
    int safetyCarOdds;
    int safetyReturnOdds;
    int safetyPitstopSubtract;
    int mistakeRolls;
    int mistakeMin;
    int mistakeMax;
    int battleRng;
    double gapMarge;
    bool tooMuchInfo;

    int fastestLap;
    int highestScore;
    int racedLaps;
    int totalLaps;
    int minLapRng;
    int maxLapRng;
    int pitMin;
    int pitMax;

    int calculated;
    int calculationCount;
    int calculationsPerAdvance = 5;
    int calculationDistance = 10;

    int lastHighestScore = 0;
    int lastLowestScore = 0;
    int safetyCarGap = 50;
    int safetyGapCloserDivider = 2;
    int safetyWearDivider = 3;
    int minimumTyreLife = -25;

    bool isFirstLap => calculated == 1;

    protected override void OnInitialized()
    {
        possibleIncidents.AddRange(Incidents.Where(e => e.State == State.Active));
        availableTyres.AddRange(Tyres.Where(e => e.State == State.Active));

        minLapRng = RaweCeek.Season.RngMinimum;
        maxLapRng = RaweCeek.Season.RngMaximum;
        pitMin = RaweCeek.Season.PitMinimum;
        pitMax = RaweCeek.Season.PitMaximum;
        mistakeRolls = RaweCeek.Season.MistakeRolls;
        mistakeMin = RaweCeek.Season.MistakeMinimum;
        mistakeMax = RaweCeek.Season.MistakeMaximum;
        safetyPitstopSubtract = RaweCeek.Season.PitCostSubtractCaution;

        fatalityOdds = Config.FatalityChance;
        disqualifyChance = Config.DisqualifyChance;
        safetyCarOdds = Config.SafetyCarChance;
        safetyReturnOdds = Config.SafetyCarReturnChance;
        safetyCarGap = Config.SafetyCarGap;
        battleRng = Config.BattleRng;
        gapMarge = Config.GapMarge;
        tooMuchInfo = Config.TooMuchInfo;
        minimumTyreLife = Config.MinimumTyreLife;

        calculationDistance = Config.CalculationDistance;
        calculationCount = RaweCeek.Race.RaceLength / calculationDistance;

        if (LapScores.Any())
            calculated = LapScores.Select(e => e.Order).Max();

        for (int i = 1; i <= calculationCount; i++)
        {
            var occurrMatch = Occurrences.FirstOrDefault(e => e.Order == i);

            if (occurrMatch != null)
                occurrences.Add(i, occurrMatch.Occurrences);
            else
                occurrences.Add(i, SituationOccurrence.Unknown);
        }

        racedLaps = NumberHelper.CalcLapCount(calculated * calculationDistance, RaweCeek.Race.Track.Length);
        totalLaps = NumberHelper.CalcLapCount(RaweCeek.Race.RaceLength, RaweCeek.Race.Track.Length);

        BuildRaceDrivers();
    }

    private void BuildRaceDrivers()
    {
        raceDrivers = RaweCeek.RaweCeekDrivers
            .OrderBy(e => e.Position)
            .Take(RaweCeek.Season.MaximumDriversInRace)
            .Select(e => e.MapToRaceDriver())
            .ToList();

        // Refactor this if persisting happens per advance
        if (RaweCeek.Race.State == State.Closed)
        {
            var scoreAbove = 0;
            foreach (var driver in raceDrivers.OrderBy(e => e.Position))
            {
                driver.LapScores = LapScores.Where(e => e.ResultId == driver.ResultId).ToList();

                if (driver.Position == 1)
                    driver.GapAbove = "LEADER";
                else
                    driver.GapAbove = "+" + (Math.Round((scoreAbove - driver.LapSum) * gapMarge, 2)).ToString("F2");

                scoreAbove = driver.LapSum;

                var lastScore = driver.LapScores.MaxBy(e => e.Order)?.Score ?? 0;
                driver.LastScore = lastScore;

                if (lastScore > lastHighestScore)
                    lastHighestScore = lastScore;
                else if (lastScore < lastLowestScore)
                    lastLowestScore = lastScore;
            }

            highestScore = raceDrivers.Max(e => e.LapSum);
        }

        loading = false;
    }

    private void ChangeCalculationPerAdvance(MudChip? calcChip)
    {
        if (calcChip != null)
            calculationsPerAdvance = (int)calcChip.Value;
    }

    private void AddCalculationSituation()
    {
        occurrences[calculated] = safetyCarOut ? SituationOccurrence.Caution : SituationOccurrence.Raced;
    }

    private int QualifyingBonus(int grid) => (raceDrivers.Count * RaweCeek.Season.GridBonus) - ((grid - 1) * RaweCeek.Season.GridBonus);

    private bool DidReliabilityFail(int reliability) => NumberHelper.RandomInt(1000) > reliability;

    private void Advance()
    {
        // Use this variable to persist the lap scores which were generated in this advance
        var lapScoresToPersist = new List<LapScore>();

        // Every i in this instance is relative to 10km (or calculationDistance) of racing aka a calculation
        for (int i = 0; i < calculationsPerAdvance; i++)
        {
            // Prevent continuing the advancing if we have already reached the limit
            if (calculated >= calculationCount)
                break;

            ++calculated;
            long? newFastestLapScorer = null;

            AddCalculationSituation();

            // Logic for what happens during a SC goes here
            if (safetyCarOut)
            {
                var safetyCarGoesBackIn = HandleSafetyMoment(lapScoresToPersist);
                if (safetyCarGoesBackIn)
                {
                    // After handling a safety car round, it goes back in
                    lapIndicatorBackground = Color.Dark;
                    lapIndicatorColour = Color.Default;
                    safetyCarOut = false;
                }

                continue;
            }

            foreach (var driver in raceDrivers.Where(e => e.Status == RaceStatus.Racing))
            {
                driver.SingleOccurrence = null;
                driver.InstantOvertaken = false;
                driver.RecentMistake = false;

                var lapScore = new LapScore { ResultId = driver.ResultId, Order = calculated };

                // Determine if either driver, car or engine has failed
                var safetyCarOccurrence = CheckReliability(driver, lapScore);

                // Calculate the score for drivers which are still racing
                if (driver.Status == RaceStatus.Racing)
                {
                    var minRng = (minLapRng + driver.RngMinMod);
                    var maxRng = (maxLapRng + driver.RngMaxMod);

                    int lapValue = NumberHelper.RandomInt(minRng, maxRng);

                    // Adds the qualifying bonus in the first lap, should be thought about once more though in terms of what we do with this
                    if (isFirstLap)
                        lapValue += QualifyingBonus(driver.Grid);

                    // Check if driver made a mistake, if so then it's going to cost him
                    for (int j = 0; j < mistakeRolls; j++)
                    {
                        if (DidReliabilityFail(driver.DriverReliability))
                        {
                            lapValue -= NumberHelper.RandomInt(mistakeMin, mistakeMax);
                            lapScore.RacerEvents |= RacerEvent.Mistake;
                            driver.RecentMistake = true;
                            break;
                        }
                    }

                    // Strategy
                    lapValue += HandleStrategy(driver, lapScore);

                    // Adds the overall power of the driver
                    lapValue += driver.Power;

                    if (lapValue > fastestLap)
                    {
                        if (calculated == 1)
                        {
                            int actualLap = lapValue - QualifyingBonus(driver.Grid);
                            if (actualLap > fastestLap)
                            {
                                fastestLap = actualLap;
                                newFastestLapScorer = driver.ResultId;
                            }
                        }
                        else
                        {
                            fastestLap = lapValue;
                            newFastestLapScorer = driver.ResultId;
                        }
                    }

                    // Finally add the score to the lap results
                    lapScore.Score = lapValue;
                }
                // If this get's triggered then the current driver caused a safety car, racing goes on as normal until the next advance
                else if (safetyCarOccurrence)
                {
                    safetyCarOut = safetyCarOccurrence;
                }

                lapScore.TyreColour = driver.CurrentTyre.Colour;
                driver.LapScores.Add(lapScore);
                lapScoresToPersist.Add(lapScore);
            }

            // Determine new positions (keep team role in mind here!)
            PostProcessAdvance(newFastestLapScorer);

            if (safetyCarOut)
            {
                lapIndicatorBackground = Color.Warning;
                lapIndicatorColour = Color.Dark;
                // Stop iterating through all advances since SC occurrence
                break;
            }
        }

        racedLaps = NumberHelper.CalcLapCount(calculated * calculationDistance, RaweCeek.Race.Track.Length);

        var lastScores = raceDrivers.Where(e => e.Status == RaceStatus.Racing).Select(e => e.LastScore).ToArray();
        if (lastScores.Any())
        {
            lastLowestScore = lastScores.Min();
            lastHighestScore = lastScores.Max();
        }

        // Persist the new stint results, yes after doing all whats needed to show them
        //PersistLapScores(lapScoresToPersist);
    }

    private bool CheckReliability(RaceDriver driver, LapScore lapScore)
    {
        var safetyCar = false;

        if (activeReliabilityCheck == Entrant.Driver && DidReliabilityFail(driver.DriverReliability))
        {
            lapScore.RacerEvents |= RacerEvent.DriverDnf;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Driver).ToList().TakeRandomIncident();
        }
        else if (activeReliabilityCheck == Entrant.Team && DidReliabilityFail(driver.CarReliability))
        {
            lapScore.RacerEvents |= RacerEvent.CarDnf;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Car).ToList().TakeRandomIncident();
        }
        else if (activeReliabilityCheck == Entrant.Engine && DidReliabilityFail(driver.EngineReliability))
        {
            lapScore.RacerEvents |= RacerEvent.EngineDnf;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Engine).ToList().TakeRandomIncident();
        }
        // Additional reliability check happens on the opening lap, as crashes are more frequent then
        else if (isFirstLap && DidReliabilityFail(driver.DriverReliability))
        {
            lapScore.RacerEvents |= RacerEvent.DriverDnf;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Driver).ToList().TakeRandomIncident();
        }
        else
        {
            return safetyCar;
        }

        // Relability failure = instant overtake by attacking drivers
        driver.InstantOvertaken = true;

        // If enabled, then we're also going to check if anyone experienced a fatal crash
        if (RaweCeek.LeagueOptions.HasFlag(LeagueOptions.EnableFatality) && (NumberHelper.RandomInt(fatalityOdds) == 0))
        {
            safetyCar = true;

            driver.Status = RaceStatus.Fatal;
            driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Lethal).ToList().TakeRandomIncident();
            lapScore.RacerEvents = RacerEvent.Death;
            lapIndicatorBackground = Color.Error;
            lapIndicatorColour = Color.Default;

            return safetyCar;
        }

        // Randomly determines the odds a safety car occured due to the DNF'ing driver
        safetyCar = NumberHelper.RandomInt(safetyCarOdds) == 0;
        driver.Status = RaceStatus.Dnf;

        return safetyCar;
    }

    // Returns a number which will be added to the users lap score
    private int HandleStrategy(RaceDriver driver, LapScore lapScore)
    {
        int assignedLifeScore = driver.TyreLife;

        var tyreMinWear = driver.CurrentTyre.WearMin + driver.WearMinMod;
        var tyreMaxWear = driver.CurrentTyre.WearMax + driver.WearMaxMod;

        if (tyreMinWear > tyreMaxWear)
        {
            tyreMaxWear = tyreMinWear + 1;
            //_snackbar.Add("A situation occurred where the maximum wear was lower than the minimum wear, please reconsider some set tyre wear values!");
        }

        // Maximum wear is more than the tyre can handle, it's time for a pitstop!
        // Or minimum wear? Or 0?
        // We might want to make this an option to something
        if (driver.CurrentTyre.PitWhenBelow > driver.TyreLife)
        {
            var distanceLeft = RaweCeek.Race.RaceLength - (calculated * calculationDistance);
            var validTyres = availableTyres.FindValidTyres(distanceLeft, RaweCeek.Climate.IsWet);

            if (validTyres.Count() > 0)
            {
                var pitCost = PitstopDriver(driver, lapScore, validTyres);

                assignedLifeScore = driver.TyreLife;
                assignedLifeScore -= pitCost;
            }
        }

        // Adds wear to the tyre
        driver.TyreLife -= NumberHelper.RandomInt(tyreMinWear, tyreMaxWear);

        if (driver.TyreLife < minimumTyreLife)
            driver.TyreLife = minimumTyreLife;

        return assignedLifeScore;
    }

    // returns bool which indicates whether a safety car has been caused by a DNF-result
    private bool HandleSafetyMoment(List<LapScore> lapScoresToPersist)
    {
        var distanceLeft = RaweCeek.Race.RaceLength - (calculated * calculationDistance);
        var validTyres = availableTyres.FindValidTyres(distanceLeft, RaweCeek.Climate.IsWet);

        int scoreAboveDriver = 0;
        foreach (var driver in raceDrivers.Where(e => e.Status == RaceStatus.Racing).OrderBy(e => e.Position))
        {
            driver.SingleOccurrence = null;
            driver.InstantOvertaken = false;

            var lapScore = new LapScore { ResultId = driver.ResultId, Order = calculated };

            // If the tyre life is less than half of the tyres overall pace, then check for a pitstop
            if (validTyres.Count() > 0 && driver.TyreLife < (driver.CurrentTyre.Pace / 2))
            {
                var pitCost = PitstopDriver(driver, lapScore, validTyres);
                lapScore.Score -= pitCost;
            }
            else
            {
                // closes the gap to the driver above
                var scoreGap = scoreAboveDriver - driver.LapSum;

                if (scoreGap > safetyCarGap)
                {
                    var closingGap = scoreGap / safetyGapCloserDivider;
                    lapScore.Score += closingGap;
                }
            }

            var tyreMinWear = driver.CurrentTyre.WearMin + driver.WearMinMod;
            var tyreMaxWear = driver.CurrentTyre.WearMax + driver.WearMaxMod;

            if (tyreMinWear > 0)
                tyreMinWear = tyreMinWear / safetyWearDivider;
            if (tyreMaxWear > 0)
                tyreMaxWear = tyreMaxWear / safetyWearDivider;

            driver.TyreLife -= NumberHelper.RandomInt(tyreMinWear, tyreMaxWear);

            if (driver.TyreLife < minimumTyreLife)
                driver.TyreLife = minimumTyreLife;

            lapScore.TyreColour = driver.CurrentTyre.Colour;

            driver.LapScores.Add(lapScore);
            lapScoresToPersist.Add(lapScore);
            scoreAboveDriver = driver.LapSum;
        }

        int positionIndexer = 0;
        foreach (var driver in raceDrivers.OrderBy(e => (int)e.Status).ThenByDescending(e => e.LapSum))
        {
            driver.Position = ++positionIndexer;

            if (positionIndexer == 1)
                driver.GapAbove = "LEADER";
            else
                driver.GapAbove = "+" + (Math.Round((scoreAboveDriver - driver.LapSum) * gapMarge, 2)).ToString("F2");

            scoreAboveDriver = driver.LapSum;
        }

        return NumberHelper.RandomInt(safetyReturnOdds) == 0;
    }

    // Returns the score cost which the pitstop took
    private int PitstopDriver(RaceDriver driver, LapScore lapScore, IEnumerable<Tyre> validTyres)
    {
        Tyre nextTyre;
        if (validTyres.Count() > 1)
            nextTyre = validTyres.Where(e => e.Id != driver.CurrentTyre.Id).ToList().TakeRandomItem();
        else
            nextTyre = validTyres.First();

        driver.CurrentTyre = nextTyre;
        driver.TyreLife = nextTyre.Pace + driver.LifeBonus;
        driver.InstantOvertaken = true;

        lapScore.RacerEvents |= RacerEvent.Pitstop;

        // Pitstop duration is reduced since this is a safety car moment
        var pitCost = NumberHelper.RandomInt(pitMin, pitMax);

        if (safetyCarOut && pitCost > safetyPitstopSubtract)
            pitCost -= safetyPitstopSubtract;

        return pitCost;
    }

    private void PostProcessAdvance(long? newFastestLapHolder)
    {
        DeterminePositions();

        highestScore = raceDrivers.Max(e => e.LapSum);

        if (newFastestLapHolder != null)
        {
            foreach (var driver in raceDrivers)
            {
                driver.HasFastestLap = false;
                if (driver.ResultId == newFastestLapHolder)
                    driver.HasFastestLap = true;
            }
        }

        // Cycle through the reliability, to check something else (otherwise we have way too many DNFs)
        reliablityCycler++;
        reliablityCycler %= cycleableReliablities.Length;
        activeReliabilityCheck = cycleableReliablities[reliablityCycler];
    }

    private void DeterminePositions()
    {
        var allPositionsAligned = false;
        // Need to re-retrieve this for every driver since their positions may change due to over overtakes (maybe) / altough i dont think this matters
        var actualPositions = GetCurrentActualPositions();

        // This likely can be optimized further
        while (!allPositionsAligned)
        {
            foreach (var driver in raceDrivers.Where(e => e.Status == RaceStatus.Racing).OrderBy(e => e.Position))
            {
                var lastScore = driver.LapScores.Last();

                int positionChange = driver.Position - actualPositions[driver.SeasonDriverId];

                // Assign the new positions based on whether their overtakes have been succesful
                if (positionChange > 0)
                    HandlePositionGain(driver, lastScore, positionChange);

                driver.LastScore = lastScore.Score;
            }

            allPositionsAligned = true;
            actualPositions = GetCurrentActualPositions();

            foreach (var driver in raceDrivers.Where(e => e.Status == RaceStatus.Racing).OrderBy(e => e.Position))
            {
                if (driver.Position != actualPositions[driver.SeasonDriverId])
                    allPositionsAligned = false;
            }
        }

        int scoreAboveDriver = 0;
        foreach (var driver in raceDrivers.Where(e => e.Status == RaceStatus.Racing).OrderBy(e => e.Position))
        {
            if (driver.Position == 1)
                driver.GapAbove = "LEADER";
            else
                driver.GapAbove = "+" + (Math.Round((scoreAboveDriver - driver.LapSum) * gapMarge, 2)).ToString("F2");

            scoreAboveDriver = driver.LapSum;
        }
    }

    private Dictionary<long, int> GetCurrentActualPositions()
    {
        var actualPositions = new Dictionary<long, int>();
        int positionIndex = 0;

        foreach (var driver in raceDrivers.OrderBy(e => (int)e.Status).ThenByDescending(e => e.LapSum))
            actualPositions.Add(driver.SeasonDriverId, ++positionIndex);

        return actualPositions;
    }

    private void HandlePositionGain(RaceDriver driver, LapScore lastScore, int gainedPositions)
    {
        while (gainedPositions > 0)
        {
            var abovePosition = driver.Position - 1;
            if (abovePosition == 0)
                break;

            var defendingDriver = raceDrivers.First(e => e.Position == abovePosition);

            // Driver above is teammate AND support driver AND attacker is main driver, swap time!
            //if (defendingDriver.SeasonTeamId == driver.SeasonTeamId 
            //    && driver.Role == TeamRole.Main 
            //    && defendingDriver.Role == TeamRole.Support)
            //{
            //    lastScore.RacerEvents |= RacerEvent.Swap;
            //    defendingDriver.LapScores.Last().RacerEvents |= RacerEvent.Swap;
            //}
            //else

            if (!defendingDriver.InstantOvertaken)
            {
                // Subtract attack value from defense, what's left is how much the attacker is hindered
                var attackingResult = driver.Attack + NumberHelper.RandomInt((battleRng * -1), battleRng);
                var defendingResult = defendingDriver.Defense + NumberHelper.RandomInt((battleRng * -1), battleRng);

                // Defender frequently made a mistake, so we're punishing him for it :)
                if (defendingDriver.RecentMistake)
                    defendingResult = defendingResult / 2;

                var battleCost = defendingResult - attackingResult;

                if (battleCost > 0)
                    lastScore.Score -= battleCost;

                // Overtake failed
                if (defendingDriver.LapSum > driver.LapSum)
                {
                    defendingDriver.DefensiveCount++;
                    break;
                }

                // It only counts as an overtake if it wasn't in an instant
                driver.OvertakeCount++;
            }

            // Overtake succeeded, driver gains a position!
            (driver.Position, defendingDriver.Position) = (defendingDriver.Position, driver.Position);

            gainedPositions--;
        }
    }

    private void PreProcessFinish()
    {
        bool anyoneDisqualified = false;

        foreach (var driver in raceDrivers.Where(e => e.Status == RaceStatus.Racing))
        {
            if (NumberHelper.RandomInt(disqualifyChance) == 0)
            {
                driver.Incident = possibleIncidents.Where(e => e.Category == CategoryIncident.Disqualified).ToList().TakeRandomIncident();
                driver.Status = RaceStatus.Dsq;

                anyoneDisqualified = true;
            }
        }

        if (anyoneDisqualified)
        {
            int positionIndex = 0;
            foreach (var driver in raceDrivers.OrderBy(e => (int)e.Status).ThenByDescending(e => e.LapSum))
                driver.Position = ++positionIndex;
        }
    }

    private async Task Finish()
    {
        PreProcessFinish();

        // Update object references
        foreach (var raceDriver in raceDrivers)
        {
            var matchDriver = RaweCeek.RaweCeekDrivers.First(e => e.ResultId == raceDriver.ResultId);
            matchDriver.Position = raceDriver.Position;
            matchDriver.Score = raceDriver.LapSum;
            matchDriver.Status = raceDriver.Status;
            matchDriver.TyreLife = raceDriver.TyreLife;
            matchDriver.Tyre = raceDriver.CurrentTyre;
            matchDriver.FastestLap = raceDriver.HasFastestLap;
            matchDriver.Overtaken = raceDriver.OvertakeCount;
            matchDriver.Defended = raceDriver.DefensiveCount;
            matchDriver.Incident = raceDriver.Incident;
        }

        // Should be removed when it is done per advance
        var allLapScores = raceDrivers.SelectMany(e => e.LapScores).Where(e => e.Id == 0).ToList();
        LapScores.AddRange(allLapScores);

        int initialHighestOccurr = 0;
        if (Occurrences.Any())
            initialHighestOccurr = Occurrences.Select(e => e.Order).Max();

        foreach (var occurr in occurrences.Where(e => e.Key > initialHighestOccurr))
        {
            Occurrences.Add(new RaceOccurrence
            {
                Order = occurr.Key,
                Occurrences = occurr.Value,
                RaceId = RaweCeek.Race.Id,
            });
        }

        await OnFinish.InvokeAsync();
    }

    private async Task ShowGapperChart() => _ = 
        await _dialog.ShowAsync<GapChartDialog>("Gapper chart", new DialogParameters { ["Drivers"] = raceDrivers });
    private async Task ShowPositionChart() => _ =
        await _dialog.ShowAsync<PositionChangeChart>("Position chart", new DialogParameters { ["Drivers"] = raceDrivers });
}
