@page "/race/{RaceId:long}"

@inject RaceService _raceService
@inject NavigationManager Nav
@inject ISnackbar Snackbar

@if (!loading)
{
    <MudTable Items="@Model.RaceDrivers.OrderBy(e => (int)e.Status).ThenBy(e => e.Position)" Dense="true" Style="width: 1600px">
        <ToolBarContent>
            <MudText>
                <CountryFlag Code="@Model.Country" />
                @Model.Name - LAPRACE ROUND @Model.Round
            </MudText>
            <MudText>weather: @Model.Weather</MudText>
            <MudText>Laps = @(lapsRaced) / @(lapCount)</MudText>
                <MudSpacer />
                @if (lapsRaced == lapCount)
            {
                <MudButton Variant="Variant.Outlined" OnClick="Finish">Finish</MudButton>
            }
            else
            {
                <MudButton Variant="Variant.Outlined" OnClick="Advance">Advance</MudButton>
            }
        </ToolBarContent>
        <HeaderContent>
            <MudTh Style="width: 15px">#</MudTh>
            <MudTh Style="width: 30px">Grid</MudTh>
            <MudTh Style="min-width: 220px">Name</MudTh>
            <MudTh Style="width: 30px">No</MudTh>
            <MudTh Style="min-width: 220px">Team</MudTh>
            <MudTh Style="width: 30px">PWR</MudTh>
            <MudTh Style="width: 50px">TYRE</MudTh>
            @for (int i = 1; i <= 5; i++)
            {
                var j = i;
                <MudTh Style="width: 30px">@j</MudTh>
            }
            <MudTh Style="min-width: 100px">Status</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd Style="@(ViewHelper.GetGradientCellStyle(context.Colour, context.Accent))">
                @context.Position
            </MudTd>
            <MudTd>@context.Grid</MudTd>
            <MudTd>
                <CountryFlag Code="@context.Nationality" Size="FlagSize.Tiny" />
                @context.FullName
            </MudTd>
            <MudTd>@context.Number</MudTd>
            <MudTd Style="@(ViewHelper.GetTeamSimpleStyle(context.Colour))">
                @context.TeamName
            </MudTd>
            <MudTd>@context.Power [@(context.NormalizedPower)]</MudTd>
            <MudTd>
                <span class="tyre" style="border-color:@(context.CurrentTyre.Colour)">
                    @context.TyreLife
                </span>
            </MudTd>
            @for (int i = 1; i <= 5; i++)
            {
                <MudTd>-</MudTd>
            }
            <MudTd>
                @if (context.Status == RaceStatus.Racing)
                {
                    <MudText>@context.DisplayGap</MudText>
                }
                else
                {
                    <MudText Color="Color.Error">@context.Incident</MudText>
                }
            </MudTd>
        </RowTemplate>
        <FooterContent>
            <MudTd colspan="20">
                <MudStack Row="true" Justify="Justify.SpaceBetween">
                    <MudIconButton Icon="@Icons.Material.Outlined.Image" Color="Color.Primary" OnClick="ShowImage" />
                    <MudIconButton Icon="@Icons.Material.Outlined.InsertChart" Color="Color.Primary" OnClick="ShowGraph" />
                </MudStack>
            </MudTd>
        </FooterContent>
    </MudTable>
}

@code {
    [Parameter] public long RaceId { get; set; }

    public RaceModel Model { get; set; }

    private bool loading = true;

    private int lapsRaced = 0;
    private int lapCount = 50;
    private int raceMinRng = 0;
    private int raceMaxRng = 10 * 50; //10*lapcount
    private int disqualifyChance = (100 / 4); // means 1/25 chance of DSQ | should read from config
    private int mistakeRolls = 2;
    private int mistakeMinCost;
    private int mistakeMaxCost;
    private double gapMarge = 0.28;

    protected override async Task OnInitializedAsync()
    {
        Model = await _raceService.RetrieveRaceModel(RaceId);

        mistakeMinCost = -30 * lapCount;
        mistakeMaxCost = -20 * lapCount;

        loading = false;
    }

    private void Advance()
    {
        int advanceLaps = 10;

        // Determine the values which impact the race like: weather and it's multipliers (configuration innit?)
        var newLapScores = new List<LapScore>();

        // Iterate through all still running drivers
        foreach (var driver in Model.RaceDrivers.Where(e => e.Status == RaceStatus.Racing))
        {
            // Check reliability
            if (ShouldCheckReliability())
            {
                var wouldDisqualify = NumberHelper.RandomInt(disqualifyChance) == 0;

                if (DidReliabilityFail(driver.DriverReliability))
                {
                    driver.Status = wouldDisqualify ? RaceStatus.Dsq : RaceStatus.Dnf;
                    driver.Incident = wouldDisqualify ? Incident.Dangerous : Incident.Damage;

                    //lapResult = wouldDisqualify ? -100000 : -50000;
                }
                else if (DidReliabilityFail(driver.CarReliability))
                {
                    driver.Status = wouldDisqualify ? RaceStatus.Dsq : RaceStatus.Dnf;
                    driver.Incident = wouldDisqualify ? Incident.Illegal : Incident.Clutch;

                    //lapResult = wouldDisqualify ? -100000 : -50000;
                }
                else if (DidReliabilityFail(driver.EngineReliability))
                {
                    driver.Status = wouldDisqualify ? RaceStatus.Dsq : RaceStatus.Dnf;
                    driver.Incident = wouldDisqualify ? Incident.Fuel : Incident.Engine;

                    //lapResult = wouldDisqualify ? -100000 : -50000;
                }
            }

            // Calculate score
            if (driver.Status == RaceStatus.Racing)
            {
                // Always multiply rng with the given lap count, add power to every lap (thats why we do that now otherwise weird calc moment inbound)
                // probs not best to calculate this here
                var minRng = (raceMinRng + driver.RngMinMod);
                var maxRng = (raceMaxRng + driver.RngMaxMod);

                for (int j = 0; j < advanceLaps; j++)
                {
                    int lapResult = NumberHelper.RandomInt(minRng, maxRng);

                    // Mistake
                    var mistake = false;
                    for (int i = 0; i < mistakeRolls; i++)
                    {
                        mistake = DidReliabilityFail(driver.DriverReliability);
                        if (!mistake)
                            break;
                    }

                    if (mistake)
                    {
                        lapResult += NumberHelper.RandomInt(mistakeMinCost, mistakeMaxCost);
                        //driverStint.RacerEvents |= RacerEvent.Mistake;
                    }

                    // TODO: Strategy
                    if (driver.WearMinMod <= driver.WearMaxMod)
                        driver.WearMinMod = driver.WearMaxMod + 1;

                    driver.TyreLife += NumberHelper.RandomInt(driver.WearMaxMod, driver.WearMinMod);

                    // ApplyDriver
                    //lapResult += driver.DriverPower;
                    // ApplyTeam
                    //lapResult += driver.CarPower;
                    // ApplyEngine
                    //lapResult += driver.EnginePower;

                    lapResult += driver.NormalizedPower;

                    driver.LapScores.Add(lapResult);
                }
            }
        }

        lapsRaced += advanceLaps;

        // Determine new positions (keep team role in mind here!)
        DeterminePositions();

        // Persist the new stint results, yes after doing all whats needed to show them
    }

    private bool ShouldCheckReliability()
    {
        if (lapsRaced == 0)
            return true;
        if (lapCount == lapsRaced)
            return true;

        // More instances when one should check reliablity?
        // Maybe a different way to determine these checks?

        return false;
    }

    private bool DidReliabilityFail(int reliability) => NumberHelper.RandomInt(100) >= reliability;

    private void DeterminePositions()
    {
        var position = 0;
        var highestScore = Model.RaceDrivers.Max(e => e.LapSum);

        foreach (var driver in Model.RaceDrivers.OrderByDescending(e => e.LapSum))
        {
            driver.Position = ++position;
            driver.DisplayGap = GapToLeader(driver.LapSum, highestScore);
        }

        // Apply the whole thing here where main/support matters
    }

    private string GapToLeader(int score, int highestScore)
    {
        double gap = ((highestScore - score) * gapMarge);

        return $"+{Math.Round(gap, 2)}";
    }

    private static int GetQualifyingBonus(int grid, int driverCount, int bonus) => (driverCount * bonus) - ((grid - 1) * bonus);

    private void ShowImage() => Snackbar.Add("Not implemented yet", Severity.Warning);

    private void ShowGraph() => Snackbar.Add("Not implemented yet", Severity.Warning);

    private async Task PersistLapScores()
    {
        // For now not implemented per advance but all in total

        var driverTotalScores = Model.RaceDrivers.ToDictionary(e => e.ResultId, e => e.LapScores);

        if (driverTotalScores?.Any() == true)
            await _raceService.PersistLapScores(driverTotalScores);
    }

    private async Task Finish()
    {
        var finishedRace = Model.ToFinishedRace();
        var finishedResults = Model.RaceDrivers.Select(e => e.ToResult()).ToList();

        // Should be removed if it is done per advance
        await PersistLapScores();

        await _raceService.FinishRace(finishedRace, finishedResults);
    }
}
