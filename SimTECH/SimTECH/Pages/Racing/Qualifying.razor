@page "/qualifying/{RaceId:long}"

@inject RaceService _raceService
@inject NavigationManager Nav

@if (loading)
{
    <MudAlert Severity="Severity.Warning">This bad boi is still loading, some patience please!</MudAlert>
}
else
{
    <MudTabs>
        <MudTabPanel Text="Q1">
            <MudTable Items="@QualifyingModel.QualifyingDrivers.OrderBy(e => e.PositionQ1)">
                <ToolBarContent>
                    <MudText>
                        <CountryFlag Code="@QualifyingModel.Country" />
                        @QualifyingModel.Name - QUALIFYING
                    </MudText>
                    <MudSpacer />
                    @if (advancedQ1 != QualifyingModel.AmountRuns)
                    {
                        <MudButton Variant="Variant.Outlined" OnClick="AdvanceQ1">Advance</MudButton>
                    }
                </ToolBarContent>
                <HeaderContent>
                    <MudTh>#</MudTh>
                    <MudTh>Driver</MudTh>
                    <MudTh>Num</MudTh>
                    <MudTh>Team</MudTh>
                    <MudTh>PWR</MudTh>
                    @for (int i = 1; i <= QualifyingModel.AmountRuns; i++)
                    {
                        var j = i;
                        <MudTh>@j</MudTh>
                    }
                    <MudTh>Score</MudTh>
                    <MudTh>Gap</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>@context.PositionQ1</MudTd>
                    <MudTd>@context.FullName</MudTd>
                    <MudTd>@context.Number</MudTd>
                    <MudTd>@context.TeamName</MudTd>
                    <MudTd>@context.Power</MudTd>
                    @foreach (var runResult in context.RunValuesQ1)
                    {
                        <MudTd>@runResult</MudTd>
                    }
                    <MudTd>@context.MaxScoreQ1</MudTd>
                    <MudTd>@context.DisplayGapQ1</MudTd>
                </RowTemplate>
            </MudTable>
        </MudTabPanel>
        <MudTabPanel Text="Q2" Disabled="@(advancedQ1 != QualifyingModel.AmountRuns)">
            @* Sorry to say this but this is fucking disguisting way to limit who gets loaded into the qualifying table *@
            <MudTable Items="@QualifyingModel.QualifyingDrivers.OrderBy(e => e.Position).Take(QualifyingModel.Season.QualifyingAmountQ2).OrderBy(e => e.PositionQ2)">
                <ToolBarContent>
                    <MudText>
                        <CountryFlag Code="@QualifyingModel.Country" />
                        @QualifyingModel.Name - QUALIFYING
                    </MudText>
                    <MudSpacer />
                    @if (advancedQ2 != QualifyingModel.AmountRuns)
                    {
                        <MudButton Variant="Variant.Outlined" OnClick="AdvanceQ2">Advance</MudButton>
                    }
                </ToolBarContent>
                <HeaderContent>
                    <MudTh>#</MudTh>
                    <MudTh>Driver</MudTh>
                    <MudTh>Num</MudTh>
                    <MudTh>Team</MudTh>
                    <MudTh>PWR</MudTh>
                    @for (int i = 1; i <= QualifyingModel.AmountRuns; i++)
                    {
                        var j = i;
                        <MudTh>@j</MudTh>
                    }
                    <MudTh>Score</MudTh>
                    <MudTh>Gap</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>@context.PositionQ2</MudTd>
                    <MudTd>@context.FullName</MudTd>
                    <MudTd>@context.Number</MudTd>
                    <MudTd>@context.TeamName</MudTd>
                    <MudTd>@context.Power</MudTd>
                    @foreach (var runResult in context.RunValuesQ1)
                    {
                        <MudTd>@runResult</MudTd>
                    }
                    <MudTd>@context.MaxScoreQ1</MudTd>
                    <MudTd>@context.DisplayGapQ2</MudTd>
                </RowTemplate>
            </MudTable>
        </MudTabPanel>
        <MudTabPanel Text="Q3" Disabled="@(advancedQ2 != QualifyingModel.AmountRuns)">
            <MudTable Items="@QualifyingModel.QualifyingDrivers.OrderBy(e => e.Position).Take(QualifyingModel.Season.QualifyingAmountQ3).OrderBy(e => e.PositionQ3)">
                <ToolBarContent>
                    <MudText>
                        <CountryFlag Code="@QualifyingModel.Country" />
                        @QualifyingModel.Name - QUALIFYING
                    </MudText>
                    <MudSpacer />
                    @if (advancedQ3 == QualifyingModel.AmountRuns)
                    {
                        <MudButton Variant="Variant.Outlined" OnClick="Finish">Finish</MudButton>
                    }
                    else
                    {
                        <MudButton Variant="Variant.Outlined" OnClick="AdvanceQ3">Advance</MudButton>
                    }
                </ToolBarContent>
                <HeaderContent>
                    <MudTh>#</MudTh>
                    <MudTh>Driver</MudTh>
                    <MudTh>Num</MudTh>
                    <MudTh>Team</MudTh>
                    <MudTh>PWR</MudTh>
                    @for (int i = 1; i <= QualifyingModel.AmountRuns; i++)
                    {
                        var j = i;
                        <MudTh>@j</MudTh>
                    }
                    <MudTh>Score</MudTh>
                    <MudTh>Gap</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>@context.PositionQ3</MudTd>
                    <MudTd>@context.FullName</MudTd>
                    <MudTd>@context.Number</MudTd>
                    <MudTd>@context.TeamName</MudTd>
                    <MudTd>@context.Power</MudTd>
                    @foreach (var runResult in context.RunValuesQ3)
                    {
                        <MudTd>@runResult</MudTd>
                    }
                    <MudTd>@context.MaxScoreQ3</MudTd>
                    <MudTd>@context.DisplayGapQ3</MudTd>
                </RowTemplate>
            </MudTable>
        </MudTabPanel>
    </MudTabs>
}

@code {
    [Parameter] public long RaceId { get; set; }

    public QualifyingModel QualifyingModel { get; set; }

    // big ass hmm about doing it like this tbh
    // this also does not work yet
    private List<SessionDriver> DriversInQ1 { get; set; }
    private List<SessionDriver>? DriversInQ2 { get; set; }
    private List<SessionDriver>? DriversInQ3 { get; set; }

    // Two ways to do this: three different racedriver lists for each session
    // Alternatively make a custom class which has an identifier for which session the values are

    private bool loading = true;
    private int advancedQ1, advancedQ2, advancedQ3 = 0;
    private double gapMarge = 0.08;

    protected override async Task OnInitializedAsync()
    {
        QualifyingModel = await _raceService.RetrieveQualifyingModel(RaceId);
        DriversInQ1 = QualifyingModel.QualifyingDrivers
            .Select(e => 
                e.CastDownwards(new SessionDriver
                {
                    SessionValues = new int[QualifyingModel.AmountRuns],
                })
            )
            .ToList();

        loading = false;
    }

    private string GapToLeader(int score, int highestScore)
    {
        double gap = ((highestScore - score) * gapMarge);

        return $"+{Math.Round(gap, 2)}";
    }

    private void AdvanceQ1()
    {
        var positionIndex = 0;

        foreach (var driver in QualifyingModel.QualifyingDrivers)
            driver.RunValuesQ1[advancedQ1] = driver.GetQualifyingResult(QualifyingModel.Season.QualifyingRNG);

        var highestScore = QualifyingModel.HighestScoreQ1();

        foreach (var driver in QualifyingModel.QualifyingDrivers.OrderByDescending(e => e.MaxScoreQ1))
        {
            driver.Position = ++positionIndex;
            driver.PositionQ1 = positionIndex;

            driver.DisplayGapQ1 = GapToLeader(driver.MaxScoreQ1, highestScore);
        }

        advancedQ1++;

        if (advancedQ1 == QualifyingModel.AmountRuns)
        {
            DriversInQ2 = DriversInQ1.OrderBy(e => e.SessionPosition).Take(QualifyingModel.Season.QualifyingAmountQ2).ToList();

            foreach (var driver in DriversInQ2)
                driver.ResetSessionResult(QualifyingModel.AmountRuns);
        }
    }

    private void AdvanceQ2()
    {
        var positionIndex = 0;

        foreach (var driver in QualifyingModel.QualifyingDrivers)
            driver.RunValuesQ2[advancedQ2] = driver.GetQualifyingResult(QualifyingModel.Season.QualifyingRNG);

        var highestScore = QualifyingModel.HighestScoreQ2();

        foreach (var driver in QualifyingModel.QualifyingDrivers.OrderByDescending(e => e.MaxScoreQ2))
        {
            driver.Position = ++positionIndex;
            driver.PositionQ2 = positionIndex;

            driver.DisplayGapQ2 = GapToLeader(driver.MaxScoreQ2, highestScore);
        }

        advancedQ2++;

        if (advancedQ2 == QualifyingModel.AmountRuns && DriversInQ2 != null)
        {
            DriversInQ3 = DriversInQ2.OrderBy(e => e.SessionPosition).Take(QualifyingModel.Season.QualifyingAmountQ3).ToList();

            foreach (var driver in DriversInQ3)
                driver.ResetSessionResult(QualifyingModel.AmountRuns);
        }
    }

    private void AdvanceQ3()
    {
        var positionIndex = 0;

        foreach (var driver in QualifyingModel.QualifyingDrivers)
            driver.RunValuesQ3[advancedQ3] = driver.GetQualifyingResult(QualifyingModel.Season.QualifyingRNG);

        var highestScore = QualifyingModel.HighestScoreQ3();

        foreach (var driver in QualifyingModel.QualifyingDrivers.OrderByDescending(e => e.MaxScoreQ3))
        {
            driver.Position = ++positionIndex;
            driver.PositionQ3 = positionIndex;

            driver.DisplayGapQ3 = GapToLeader(driver.MaxScoreQ3, highestScore);
        }

        advancedQ3++;
    }

    private async Task Finish()
    {
        var positionResults = QualifyingModel.QualifyingDrivers.ToDictionary(e => e.ResultId, e => e.Position);

        await _raceService.PersistGridPositions(positionResults, RaceId);

        Nav.NavigateTo("/raceweek/" + RaceId);
    }

    // Not used yet but I get the idea something like this could be used to implement a more generic solution in favour of hardcoded sessions
    private class SessionDriver : QualifyingDriver
    {
        public int[] SessionValues { get; set; }
        public int SessionPosition { get; set; }
        public string LeaderGap { get; set; } = string.Empty;

        public int MaxScore => SessionValues.Max();

        public void ResetSessionResult(int runAmount)
        {
            SessionValues = new int[runAmount];
            LeaderGap = string.Empty;
        }
    }
}
